1. Определите структуру Array – одномерный массив вещественных чисел:
struct Array
{
	double * vec;		//непосредственно вектор
	unsigned size;	//размер вектора
	int last;			//индекс последнего элемента
};
Определите следующие функции: NewArray() – создание нового массива, размер которого передается в качестве параметра. Функция возвращает указатель на новый массив, DelArray() – полное освобождение памяти занятой массивом, Add() – добавление нового значения в массив, Del() – удаление из массива i-го элемента, Print() – вывод элементов массива на экран.


2. Определите класс Array – одномерный массив вещественных чисел:
class Array
{
	double * arr;	//непосредственно массив
	unsigned size;	//размер массива
	...
};
Определите в классе следующие функции:
Init() – создание нового массива, размер которого передается в качестве параметра;
DelArray() – освобождение памяти занятой массивом;
Set() – установить новое значение i-го элемента массива;
Get() – получить значение i-го элемента массива;
Print() – дружественная функция вывода элементов массива на экран.


3. Определите класс Array – одномерный массив вещественных чисел:
class Array
{
	double * arr;	//непосредственно массив
	unsigned size;	//размер массива
	...
};
Определите в классе следующие функции:
Init() – создание нового массива, размер которого передается в качестве параметра;
DelArray() – освобождение памяти занятой массивом;
Set() – установить новое значение i-го элемента массива;
Get() – получить значение i-го элемента массива;
Print() – дружественная функция вывода элементов массива на экран.
Определить в классе конструкторы: по умолчанию, с параметрами, копирования. Определить деструктор.


4. Определите в классе Array следующие операции:
Array& operator=(const Array&);//копирование массива
Array& operator+=(const Array&);//добавление массива
Array& operator+=(double);//добавление нового элемента в массив
double& operator[](int);//получение доступа к элементу массива
friend istream& operator>>(istream& is, Array&);//ввод значений
friend ostream& operator>>(ostream& os, Array&);//вывод массива


5. Разработать следующую иерархию классов для ролевой игры:
class Weapon
{
protected:
//имя
	char name[20];
//сила удара
	int blow_power;
//сила защиты
	int protect_power;
public:
//конструктор
	Weapon(int bp, int pp)
	{
		blow_power = bp;
		protect_power = pp;
	}
//ударить
	virtual int Strike();
//защититься
	virtual int Protect(int power);
//возвратить имя оружия
	char * GetName();
};
class Shield:public Weapon //щит
{/*
в классе необходимо определить конструктор и 
переопределить функции Strike() и Protect()
*/};
class Club:public Weapon //дубинка
{/*
в классе необходимо определить конструктор и
переопределить функции Strike() и Protect()
*/};
class Sword:public Weapon //меч
{/*
в классе необходимо определить конструктор и
переопределить функции Strike() и Protect()
*/};
Конструктор класса Weapon устанавливает значения силы удара и защиты.
Функция Strike() генерирует случайное число в диапазоне от 0 до blow_power, уменьшает blow_power на значение равное частному от деления сгенерированного числа на 10 и возвращает сгенерированное число.
Функция Protect() получает силу удара, генерирует случайное число в диапазоне от 0 до protect_power, уменьшает protect_power на значение равное частному от деления сгенерированного числа на 10, вычисляет разницу между силой удара power и сгенерированным числом и, если результат положительный то возвращается это число, если нет то возвращается 0. Возвращаемое значение есть сила повреждения.
class Personage
{
protected:
//имя
	char name[20];
//удача в атаке
	int luck_attack;
//удача в защите
	int luck_guard;
//здоровье
	int health;
//оружие нападения
	Weapon * weapon_attack;
//оружие защиты
	Weapon * weapon_guard;
public:
	Personage(char *);
	virtual void Attack(Personage*);
	virtual void Guard(int);
//false – игрок еще жив, иначе true
	bool IsDead() { return (health <= 0); }
//установить оружие атаки
	void SetWeaponAttack(Weapon * w)
	{
		weapon_attack = w;
	}
//установить оружие защиты
	void SetWeaponGuard(Weapon * w)
	{
		weapon_guard = w;
	}
};
class Warrior:public Personage //воин
{/*
в классе необходимо определить конструктор и
переопределить функции Attack() и Guard()
*/};
class Monster:public Personage //монстр
{/*
в классе необходимо определить конструктор и
переопределить функции Attack() и Guard()
*/};
Функция Attack() инициирует атаку игроком противника. В начале функция выбирает случайным образом оружие и вычисляет силу удара. Затем вычисляется удача в атаке по следующей формуле:
удача_в_атаке = случайное_число(-сила_удара/2, сила_удара/2)
Сила удара суммируется с удачей и передается функции Guard() противника.
Функция Guard() инициирует защиту от нападения противника. Вначале функция выбирает случайно оружие для защиты и вычисляет силу повреждения. Затем вычисляет удачу в защите по аналогичной для атаки схеме, вычитает удачу из силы повреждения и полученный результат вычитается из здоровья.
Разработать класс Combat для моделирования поединка между двумя персонажами с использованием оружия. Конструктор класса должен запрашивать тип персонажей и предлагать на выбор оружие. Функция Start() должна случайно выбирать игрока, который будет ходить (атаковать). Результаты ходов должны отображаться на экране, например:
ход 1:
атака имя:	сила_удара	удача	рез_сила	здоровье
защита имя:	сила_поврежд	удача	рез_поврежд	здоровье
...
ход 5:
атака имя:	сила_удара	удача	рез_сила	здоровье
защита имя:	сила_поврежд	удача	рез_поврежд	здоровье
...
Как только игрок погибает бой прекращается.
class Combat
{
	Personage * p1; //игрок 1
	Personage * p2; //игрок 2
	Personage * a_player; //атакующий игрок
	Personage * g_player; //защищающийся игрок
public:
	Combat();
	~Combat();
	void Start();
};


6. Определите класс Vector для хранения векторных данных:
template <class T, int size>
class Vector
{
	T vec[size];
	...
};
Определите в классе следующие функции:
Vector(); – конструктор по умолчанию, который устанавливает значения элементов вектора в 0;
T& operator[](int index); – получение элемента по его индексу;
friend ostream& operator<<(ostream&, Vector<T>&); – перенаправление вывода;
friend istream& operator>>(istream&, Vector<T>&); – перенаправление ввода.


7. Создайте иерархию классов для представления исключений трансцендентных операций. Например:
class TranscException
{
	double value;
	char opname[20];
public:
	TranscException(char * nameop, double val);
	virtual char * Message() = 0;
};
//исключения логарифмических функций
class LogException : public TranscException;
//исключения тригонометрических функций
class TrigException : public TranscException;
Разработайте класс
class Trans
{
public:
	double Sin(double angle); //синус
	double Cos(double angle); //косинус
	double Tan(double angle); //тангенс
	double Asin(double sn);   //арксинус
	double Acos(double cs);   //арккосинус
	double Atan(double tg);   //арктангенс
	double Ln(double value);  //натуральный логарифм
	double Lg(double value);  //десятичный логарифм
};
Каждая функция должна отслеживать исключительные ситуации при выполнении операций и генерировать исключение соответствующего типа.